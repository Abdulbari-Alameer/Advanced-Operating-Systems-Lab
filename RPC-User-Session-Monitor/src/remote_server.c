/*
 * File: remote_server.c
 * Purpose: RPC server that implements remote "who" functionality
 * 
 * Compilation:
 * gcc -o remote_server remote_server.c remote_svc.c remote_xdr.c -lnsl
 * 
 * Usage:
 * ./remote_server
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <utmp.h>
#include <time.h>
#include "remote.h"  /* Generated by rpcgen */

#define UTMP_FILE "/var/run/utmp"

/*
 * Remote Procedure 1: GET_LOGGED_USERS
 * Returns structured information about logged-in users
 */
user_list * get_logged_users_1_svc(void *argp, struct svc_req *rqstp) {
    static user_list result;
    FILE *utmp_file;
    struct utmp ut_entry;
    int count = 0;
    
    /* Initialize result */
    result.count = 0;
    result.users.users_len = 0;
    result.users.users_val = NULL;
    
    printf("Server: Received request for logged-in users\n");
    
    /* Allocate memory for user array */
    result.users.users_val = (user_info *)malloc(MAX_USERS * sizeof(user_info));
    if (result.users.users_val == NULL) {
        fprintf(stderr, "Server: Memory allocation failed\n");
        return &result;
    }
    
    /* Open utmp file */
    utmp_file = fopen(UTMP_FILE, "rb");
    if (utmp_file == NULL) {
        perror("Server: Error opening utmp file");
        free(result.users.users_val);
        result.users.users_val = NULL;
        return &result;
    }
    
    /* Read utmp entries */
    while (fread(&ut_entry, sizeof(struct utmp), 1, utmp_file) == 1) {
        if (ut_entry.ut_type == USER_PROCESS && count < MAX_USERS) {
            time_t login_time = ut_entry.ut_time;
            struct tm *tm_info = localtime(&login_time);
            
            /* Copy user information */
            strncpy(result.users.users_val[count].username, 
                    ut_entry.ut_user, 31);
            result.users.users_val[count].username[31] = '\0';
            
            strncpy(result.users.users_val[count].terminal, 
                    ut_entry.ut_line, 31);
            result.users.users_val[count].terminal[31] = '\0';
            
            strncpy(result.users.users_val[count].hostname, 
                    ut_entry.ut_host, 255);
            result.users.users_val[count].hostname[255] = '\0';
            
            strftime(result.users.users_val[count].logintime, 63, 
                     "%Y-%m-%d %H:%M", tm_info);
            result.users.users_val[count].logintime[63] = '\0';
            
            count++;
        }
    }
    
    fclose(utmp_file);
    
    result.count = count;
    result.users.users_len = count;
    
    printf("Server: Sending information for %d user(s)\n", count);
    
    return &result;
}

/*
 * Remote Procedure 2: GET_USERS_STRING
 * Returns simple string format (like "w" command output)
 */
char ** get_users_string_1_svc(void *argp, struct svc_req *rqstp) {
    static char *result;
    static char buffer[4096];
    FILE *utmp_file;
    struct utmp ut_entry;
    int offset = 0;
    
    printf("Server: Received request for user string\n");
    
    /* Initialize buffer with header */
    offset = snprintf(buffer, sizeof(buffer),
                     "%-10s %-10s %-16s %s\n"
                     "================================================\n",
                     "USER", "TTY", "FROM", "LOGIN@");
    
    /* Open utmp file */
    utmp_file = fopen(UTMP_FILE, "rb");
    if (utmp_file == NULL) {
        perror("Server: Error opening utmp file");
        result = "Error: Cannot open utmp file\n";
        return &result;
    }
    
    /* Read and format utmp entries */
    while (fread(&ut_entry, sizeof(struct utmp), 1, utmp_file) == 1) {
        if (ut_entry.ut_type == USER_PROCESS) {
            time_t login_time = ut_entry.ut_time;
            struct tm *tm_info = localtime(&login_time);
            char time_str[64];
            
            strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M", tm_info);
            
            offset += snprintf(buffer + offset, sizeof(buffer) - offset,
                             "%-10s %-10s %-16s %s\n",
                             ut_entry.ut_user,
                             ut_entry.ut_line,
                             ut_entry.ut_host,
                             time_str);
            
            if (offset >= sizeof(buffer) - 100) {
                break;  /* Buffer nearly full */
            }
        }
    }
    
    fclose(utmp_file);
    
    result = buffer;
    return &result;
}

/*
 * EXPLANATION:
 * 
 * 1. Function naming convention:
 *    - Format: <procedure_name>_<version>_svc
 *    - Must match definition in remote.x
 * 
 * 2. Static variables:
 *    - Required because RPC returns pointer to result
 *    - Result must persist after function returns
 *    - Server handles one request at a time
 * 
 * 3. Memory management:
 *    - malloc() for dynamic arrays
 *    - free() not needed as static variable reused
 *    - Client stub handles XDR marshalling
 * 
 * 4. Error handling:
 *    - Check fopen() return value
 *    - Check malloc() return value
 *    - Return valid result structure even on error
 */