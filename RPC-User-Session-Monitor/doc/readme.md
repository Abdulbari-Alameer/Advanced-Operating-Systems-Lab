# RPC Who Command Implementation

A distributed system implementation that displays logged-in users using Remote Procedure Call (RPC) in C. This project demonstrates client-server communication using Sun RPC protocol on Linux.



##  Overview

This project implements the Unix `who` command functionality in two ways:

1. **Part A (Local)**: Reads the `/var/run/utmp` database directly to display currently logged-in users
2. **Part B (RPC)**: Uses Remote Procedure Call (RPC) to fetch user information from a remote server

The project showcases distributed computing concepts, inter-process communication, and system programming in C.


# Complete Execution Guide

## Prerequisites

1. **Install required packages** (Ubuntu/Debian):
```bash
sudo apt-get update
sudo apt-get install rpcbind libc-dev build-essential
```

2. **Start RPC port mapper**:
```bash
sudo service rpcbind start
# or
sudo systemctl start rpcbind
```

## Part (a): Local Who Command

### Step 1: Create and Compile
```bash
# Save the code as local_who.c
gcc -o local_who local_who.c

# Or use make
make local_who
```

### Step 2: Run
```bash
./local_who
```

### Expected Output:
```
Currently logged-in users:
USER       TTY        FROM             LOGIN@
================================================================
john       pts/0      192.168.1.100    2024-01-15 10:30
alice      tty1       :0               2024-01-15 09:15
```

---

## Part (b): RPC Implementation

### Step 1: Create All Files
Save the following files in the same directory:
- `remote.x`
- `remote_server.c`
- `remote_client.c`
- `Makefile`

### Step 2: Generate RPC Stubs
```bash
rpcgen remote.x
```

This creates:
- `remote.h` - Header file
- `remote_clnt.c` - Client stub
- `remote_svc.c` - Server stub
- `remote_xdr.c` - XDR serialization routines

### Step 3: Compile Programs
```bash
# Compile server
gcc -o remote_server remote_server.c remote_svc.c remote_xdr.c -lnsl

# Compile client
gcc -o remote_client remote_client.c remote_clnt.c remote_xdr.c -lnsl

# Or use make
make all
```

### Step 4: Run RPC Programs

**Terminal 1 (Server):**
```bash
./remote_server
```

Server output:
```
Server: Received request for logged-in users
Server: Sending information for 2 user(s)
```

**Terminal 2 (Client):**
```bash
# For structured output
./remote_client localhost 1

# For string output
./remote_client localhost 2

# For remote machine
./remote_client 192.168.1.50 1
```

Client output:
```
Connecting to RPC server on host: localhost
Successfully connected to server

Calling remote procedure: GET_LOGGED_USERS
==================================================
Received information for 2 user(s):

USER       TTY        FROM             LOGIN@
================================================================
john       pts/0      192.168.1.100    2024-01-15 10:30
alice      tty1       :0               2024-01-15 09:15

Client finished successfully
```

---

## Understanding the RPC Flow

### 1. **Server Startup**
```
remote_server starts
  ↓
Registers with portmapper (rpcbind)
  ↓
Listens for incoming RPC requests
  ↓
Waits for client connections
```

### 2. **Client Request**
```
remote_client starts
  ↓
clnt_create() - Creates CLIENT handle
  ↓
Contacts portmapper to find server port
  ↓
Establishes connection to server
  ↓
Calls remote procedure
  ↓
Receives and displays result
  ↓
clnt_destroy() - Cleans up
```

### 3. **Server Processing**
```
Server receives RPC request
  ↓
Calls get_logged_users_1_svc()
  ↓
Opens /var/run/utmp
  ↓
Reads user entries (struct utmp)
  ↓
Filters USER_PROCESS type entries
  ↓
Builds result structure
  ↓
Returns result to client (via XDR)
```

---

## Key Concepts Explained

### 1. **struct utmp Structure**
Located in `<utmp.h>`, contains:
- `ut_type`: Entry type (USER_PROCESS, INIT_PROCESS, etc.)
- `ut_user`: Username (login name)
- `ut_line`: Terminal device name
- `ut_host`: Remote hostname
- `ut_time`: Login timestamp
- `ut_pid`: Process ID

### 2. **/var/run/utmp File**
- Binary file, not human-readable
- Records current login sessions
- Updated by login, init, and getty
- Read using fopen() in binary mode ("rb")

### 3. **RPC Components**

**remote.x (Interface Definition):**
- Defines data structures
- Declares remote procedures
- Specifies program and version numbers

**Client Stub (remote_clnt.c):**
- Generated by rpcgen
- Marshals arguments
- Sends request to server
- Unmarshals results

**Server Stub (remote_svc.c):**
- Generated by rpcgen
- Receives requests
- Unmarshals arguments
- Calls actual procedure
- Marshals results

**XDR Routines (remote_xdr.c):**
- Serialization/deserialization
- Platform-independent data representation

### 4. **Important RPC Functions**

**clnt_create():**
- Creates client handle
- Parameters: host, program, version, protocol
- Returns CLIENT* or NULL

**clnt_pcreateerror():**
- Prints why clnt_create() failed
- Includes network errors, server not found, etc.

**clnt_perror():**
- Prints RPC call errors
- Includes timeout, version mismatch, etc.

**clnt_destroy():**
- Frees CLIENT handle
- Closes connections
- Must be called before exit

---

## Troubleshooting

### Problem 1: "Cannot register service"
**Solution:**
```bash
# Check if rpcbind is running
sudo service rpcbind status

# Start if not running
sudo service rpcbind start

# Check registered services
rpcinfo -p
```

### Problem 2: "RPC: Program not registered"
**Solution:**
- Ensure server is running before starting client
- Check firewall rules
- Verify program number in remote.x

### Problem 3: Permission denied reading /var/run/utmp
**Solution:**
```bash
# Run with appropriate permissions
sudo ./local_who
# or
sudo ./remote_server
```

### Problem 4: Compilation errors with -lnsl
**Solution:**
```bash
# On newer systems, try without -lnsl
gcc -o remote_server remote_server.c remote_svc.c remote_xdr.c

# Or install libc6-dev
sudo apt-get install libc6-dev
```

---

## Testing Tips

1. **Test locally first:**
   ```bash
   ./remote_client localhost 1
   ```

2. **Test across network:**
   ```bash
   # On server machine
   ./remote_server
   
   # On client machine
   ./remote_client <server-ip> 1
   ```

3. **Check server logs:**
   Server prints messages for each request

4. **Use both procedures:**
   Test both procedure 1 (structured) and 2 (string)

---

## Additional Notes

### Security Considerations
- RPC communication is unencrypted
- No authentication by default
- Suitable for trusted networks only
- For production, consider:
  - RPCSEC_GSS for authentication
  - SSH tunneling for encryption
  - Firewall rules to restrict access

### Performance
- UDP: Faster, no connection overhead
- TCP: Reliable, better for large data
- Consider timeout settings for slow networks

### Alternatives to RPC
- REST APIs (HTTP-based)
- gRPC (Google's RPC framework)
- Message queues (RabbitMQ, Kafka)
- WebSockets for real-time communication

---

## Summary

**Part (a):** Simple C program reads `/var/run/utmp` directly using `fopen()` and `fread()` to display logged-in users.

**Part (b):** Extends functionality using Sun RPC:
- Client triggers request remotely
- Server processes request and reads utmp
- Communication handled by RPC framework
- Results serialized via XDR and sent to client

Both implementations achieve the same goal of listing logged-in users, but the RPC version enables remote access across network.

